# P 104

# 聚类分析
     在没有给定分类的情况下，按照数据的相似度进行样本分组的方法
     分类模型需要使用有类别标记构成的训练数据，聚类模型可以建立在无类标记的数据上，是一种非监督的学习算法
     聚类分组的原则：
          按照自身距离或相似度划分为若干组，组类距离最小化而外部距离最大化
     作用：
          细分领域特别有效
          可以将连续数据离散化
          
# K-means 聚类算法
     基于距离的非层次聚类算法。在最小化误差函数的基础上将数据划分为k类，采用距离作为指标
     原理简单并且适合处理大量数据
     
处理连续属性，需先对各属性值进行零-均值规范
处理文档属性，需先将文档整理成文档-词矩阵的形式
     
===

#使用K-Means算法聚类消费行为特征数据
import pandas as pd
#参数初始化
inputfile = '数据源\\图书配套数据、代码\\chapter5\\demo\\data\\consumption_data.xls' #销量及其他属性数据
outputfile = '数据源\\图书配套数据、代码\\chapter5\\demo\\tmp\\data_type.xls' #保存结果的文件名

d = pd.read_excel(inputfile, index_col = 'Id') #读取数据
d_zs = 1.0*(data - data.mean())/data.std() #数据标准化

from sklearn.cluster import KMeans
k = 3 #聚类的类别
iteration = 500 #聚类最大循环次数
model = KMeans(n_clusters = k, n_jobs = 4, max_iter = iteration) #分为k类，并发数4
model.fit(d_zs) #开始聚类

#简单打印结果
r1_s = pd.Series(model.labels_).value_counts() #统计各个类别的数目
r1_d = pd.DataFrame(model.cluster_centers_) #找出聚类中心
r2_d = pd.concat([r1_d, r1_s], axis = 1) #横向连接（0是纵向），得到聚类中心对应的类别下的数目
r2_d.columns = list(d.columns) + [u'类别数目'] #重命名表头

# 还原的数据归到 聚类类别
r_d = pd.concat([d, pd.Series(model.labels_, index = d.index)], axis = 1)  #详细输出每个样本对应的类别
r_d.columns = list(d.columns) + [u'聚类类别'] #重命名表头

r0_d = (r_d[r_d[u'聚类类别']==0]).iloc[:,0:3]

import matplotlib.pyplot as plt
plt.rcParams['font.sans-serif'] = ['SimHei'] #用来正常显示中文标签
plt.rcParams['axes.unicode_minus'] = False #用来正常显示负号

r0_d.plot(kind='kde', linewidth = 2, subplots = True, sharex = False)#subplots分离成独立图像，sharex使用同一个x轴
plt.ylabel('密度')
plt.legend()
plt.show()
=

# 用 for in 处理批量
import matplotlib.pyplot as plt
plt.rcParams['font.sans-serif'] = ['SimHei'] #用来正常显示中文标签
plt.rcParams['axes.unicode_minus'] = False #用来正常显示负号

plt.figure()
for i in range(k):
    r012_d = (r_d[r_d[u'聚类类别']==i]).iloc[:,0:3]
    r012_d.plot(kind='kde', linewidth = 2, subplots = True, sharex = False)
    plt.ylabel(u'密度'+str(i))
    plt.xlabel(u'人数'+str(i))
    plt.legend()
    plt.show()


