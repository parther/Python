# 问题：
     
Using Theano backend.
WARNING (theano.configdefaults): g++ not available, if using conda: `conda install m2w64-toolchain`
ValueError: Invalid argument "metric" passed to K.function with Theano backend
This error means that you are running Keras version 0 (e.g. 0.3.2) but running code that was written for Keras version 1. 
You can upgrade to Keras 1, or remove metrics=['accuracy'] from the function call to model.compile()
net.compile(loss = 'binary_crossentropy', optimizer = 'adam')
d.as_matrix() d.as_matrix 的区别
 
#
修改Keras.jason 解决backend 问题
import math
1 math.floor(2.3)
2 math.ceil(2.3) 
3 round(2.3)

Sequential model The simplest type of model a linear stack of layers
https://keras.io/#getting-started-30-seconds-to-keras

信号的正向传播和误差的逆向传播两个过程组成
训练样本需为array类型
===
import pandas as pd
from random import shuffle

datafile = '数据源\\图书配套数据、代码\\chapter6\\demo\\data\\model.xls'
data = pd.read_excel(datafile)
data = data.as_matrix()
shuffle(data)

p = 0.8 #设置训练数据比例
train = data[:int(len(data)*p),:]
test = data[int(len(data)*p):,:]
===

#构建LM神经网络模型
from keras.models import Sequential #导入神经网络初始化函数
from keras.layers.core import Dense, Activation #导入神经网络层函数、激活函数

netfile = '数据源\\图书配套数据、代码\\chapter6\\demo\\tmp\\net.model' #构建的神经网络模型存储路径
net = Sequential() #建立神经网络
net.add(Dense(input_dim = 3, units = 10)) #添加输入层（3节点，自变量3个属性）到隐藏层（10节点）的连接
net.add(Activation('relu')) #隐藏层使用relu激活函数
net.add(Dense(input_dim = 10, units = 1)) #添加隐藏层（10节点）到输出层（1节点）的连接
net.add(Activation('sigmoid')) #输出层使用sigmoid激活函数
net.compile(loss = 'binary_crossentropy', optimizer = 'adam') #编译模型，使用adam方法求解

net.fit(train[:,:3], train[:,3], epochs=1000, batch_size=1) #训练模型，循环1000次
net.save_weights(netfile) #保存模型 

net.predict_classes(a) # 预测 net.predict出来的只是概率
===
 
# 构建混淆矩阵
from cm_plot import * #导入自行编写的混淆矩阵可视化函数
cm_plot(train[:,3], predict_result).show() #显示混淆矩阵可视化结果
=

# 混淆矩阵函数
def cm_plot(y, yp):
    from sklearn.metrics import confusion_matrix
    cm = confusion_matrix(y, yp) 
    import matplotlib.pyplot as plt 
    plt.matshow(cm, cmap=plt.cm.Greens) 
    plt.colorbar() 
    for x in range(len(cm)): 
        for y in range(len(cm)):
            plt.annotate(cm[x,y], xy=(x, y), horizontalalignment='center', verticalalignment='center')
  
    plt.ylabel('True label') 
    plt.xlabel('Predicted label') 
    return plt
===
 
# 构建ROC曲线
from sklearn.metrics import roc_curve #导入ROC曲线函数

predict_result = net.predict(test[:,:3]).reshape(len(test))
fpr, tpr, thresholds = roc_curve(test[:,3], predict_result, pos_label=1)
plt.plot(fpr, tpr, linewidth=2, label = 'ROC of LM') #作出ROC曲线
plt.xlabel('False Positive Rate') #坐标轴标签
plt.ylabel('True Positive Rate') #坐标轴标签
plt.ylim(0,1.05) #边界范围
plt.xlim(0,1.05) #边界范围
plt.legend(loc=4) #图例
plt.show() #显示作图结果


