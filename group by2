# 参考：http://blog.csdn.net/youngbit007/article/details/54288603
# 单个分组
     g_d2 = d.groupby(['Type 1'])
     
# 多个分组
     g_d2 = d.groupby(['Type 1','Type 2'])
     
# 基本使用方法
     g_d2.first() # 获得分组的第一个值
     g_d2.size()#获得每个分组值 的数量
     g_d2.describe()#获得基本统计量
          g_d2[['HP']].sum() # [] 返回数据框
          g_d2['HP'].sum() # 返回series
          g_d2.agg(np.sum)[['HP']] #效果一样
     g_d2.groups # 获得分组数据对应的索引
     g_d2.get_group('Bug') #获得单个分组数据对应的索引 及 其他 值 
     
     for name,group in g_d1: # name,group 一般配合一起使用，单独使用会打印出整个数据表。name 是分组值相当于索引，group 是分组对应的内容
         print(name)
         print(group)
         
     for (k1,k2),group in g_d2: # 两个分组的情况，内容同上，主要是用于打印显示数据
         print (k1,k2)
         print (group)

dict(list(g_d1)) # 将分组用dict的形式 显示出来
dict(list(g_d1))['a'] # 将某个分组值 用表格打印出来
g_d2[['data1']].mean() # 选择某列 进行聚合

# 按列分组，指定列分组
dic = {'a':'red','b':'red','c':'blue','d':'blue','e':'red'} # 使用 series 是一样的效果
g_d1 = d.groupby(dic,axis=1)
g_d1.count()

# 传入函数 进行分组
g_d1 = d.groupby(len)
g_d1 = d.groupby([len,l]) # 函数 与列表搭配分组使用

# 多重索引 与 分组
columns = pd.MultiIndex.from_arrays([['US','US','US','JP','JP'],[1,3,5,1,3]],names=['cty','tenor'])
d = pd.DataFrame(np.random.randn(4,5),columns=columns)
d.groupby(level='cty',axis=1).count()

分组运用函数
def f(a):
    return a.max()
g_d1 = d.groupby('key1')
g_d1.agg(f) # f 会作用与每个分组
g_d1.agg('max') # 'max'等基本统计函数 亦可 直接作用

聚合只是分组运算的一种，它是数据转换的特列
g_d1.transform(lambda x: x.max()) # 传入函数，返回的是整个列表
g_d1.apply(top) # apply 传入的是最一般化的 函数

agg,transform,apply 都传入函数，但用法不同
unstack 适用于两个分组，直观显示
apply中，第二个参数是所引入函数的第二个参数
axis是apply,agg中的参数。axis=0表示将函数作用在d的行，axis=1则是列。此时的统计函数不起作用
d.apply(lambda x:x[0]+x[1] , axis=0)
apply,agg 参数可以直接接 基本统计量函数的名称，接其他函数前面必须带pd且没有分号
unique_d2.apply('std')
unique_d2.apply(pd.value_counts)
pd.cut 将数据分组
     pd.cut(s,3,labels=['a','b','c'])
