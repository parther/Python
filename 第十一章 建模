# 问题：
极大似然比方法
from statsmodels.tsa.stattools import adfuller as ADF
FutureWarning: The pandas.core.datetools module is deprecated and will be removed in a future version. 
Please use the pandas.tseries module instead.
from pandas.core import datetools

bic_matrix_d = pd.DataFrame(bic_matrix) 定阶的值在变
lagnum = 12
p2 = (p < 0.05).sum()

显著性水平 
平稳性的结果与书上的不一样 数据其实没什么问题
final_d = final_d.iloc[:len(final_d)-5] # 不使用最后5个数据是为了拿来预测
LB 统计量 Ljung-Box

try: #存在部分报错，所以用try来跳过报错。
tmp.append(ARIMA(s, (p,1,q)).fit().bic)
except:

ConvergenceWarning: Maximum Likelihood optimization failed to converge. Check mle_retvals
# 
基本步骤：
平稳性检验 - 差分运算 - 白噪声检验
BIC 定阶，模型识别，确认模型的p、q参数
预测 - 检验

时间列须为 时间格式，时间由前到后排序
差分 本行减去上一行的差值
from statsmodels.tsa.stattools import adfuller as ADF
[p] = acorr_ljungbox(s, lags = 1)[1]  将单个数字从array中提取出来
为了保证数据信息提取完毕，需要保证原始数据非白噪声，差分后为白噪声
hessian matrix 海赛矩阵
inversion 反转
===

# 平稳性检验
import numpy as np
import pandas as pd
from pandas import Series, DataFrame

f = '数据源\\图书配套数据、代码\\chapter11\\demo\\tmp\\discdata_processed.xls'
d = pd.read_excel(f, index_col = 'COLLECTTIME')
d2 = d.iloc[:len(d)-5]
s = d2['CWXT_DB:184:D:\\']
d2.head()

from statsmodels.tsa.stattools import adfuller as ADF
diff_x = 0
adf = ADF(s)
while adf[1] > 0.004: # 验证差分后的结果是否符合 显著性水平 
    diff_x = diff_x + 1
    adf = ADF(s.diff(diff_x).dropna())
print('通过 %s 次差分 后的 p 值为：%s' %(diff_x, adf[1]))
===

# 检验白噪声
from statsmodels.stats.diagnostic import acorr_ljungbox
[p] = acorr_ljungbox(s, lags = 1)[1]
if p < 0.05:
    print(u'原始序列为非白噪声序列，对应的p值为：%s' %p)
else:
    [p] = acorr_ljungbox(s.diff().dropna(), lags = 1)[1]
    print(u'原始该序列为白噪声序列，对应的p值为：%s' %p)
===

#定阶, 模型识别，确定模型
from statsmodels.tsa.arima_model import ARIMA
pmax = int(len(s)/10) #一般阶数不超过length/10
qmax = int(len(s)/10) #一般阶数不超过length/10
bic_matrix = [] #bic矩阵
for p in range(pmax+1):
    tmp = []
    for q in range(qmax+1):
        try: #存在部分报错，所以用try来跳过报错。
            tmp.append(ARIMA(s, (p,1,q)).fit().bic)
        except:
            tmp.append(None)
    bic_matrix.append(tmp)

bic_matrix = pd.DataFrame(bic_matrix) #从中可以找出最小值
p,q = bic_matrix.stack().idxmin() #先用stack展平，然后用idxmin找出最小值位置。
print(u'BIC最小的p值和q值为：%s、%s' %(p,q))
===

# 模型检验
arima = ARIMA(s, (0, 1, 1)).fit() #建立并训练模型
s_pred = arima.predict(typ = 'levels') # 反过来预测s的值，缺少s的第一个值，因为前面dropna了
pred_error = (s_pred - s).dropna() # 残差序列中如果不是白噪声，说明信息未提取完整，需修改模型

lagnum = 12 # 
p = acorr_ljungbox(pred_error, lags = lagnum)[1]
p2 = (p < 0.05).sum() #p值小于0.05，认为是非白噪声,白噪声是相加的值
if p2 > 0:
  print(u'模型ARIMA(0,1,1)不符合白噪声检验')
else:
  print(u'模型ARIMA(0,1,1)符合白噪声检验')
===

# 模型评价
#参数初始化
file = '数据源\\图书配套数据、代码\\chapter11\\demo\\data\\predictdata.xls'
data = pd.read_excel(file)

#计算误差
abs_ = (data[u'预测值'] - data[u'实际值']).abs()
mae_ = abs_.mean() # mae
rmse_ = ((abs_**2).mean())**0.5 # rmse
mape_ = (abs_/data[u'实际值']).mean() # mape

print(u'平均绝对误差为：%0.4f，\n均方根误差为：%0.4f，\n平均绝对百分误差为：%0.6f。' %(mae_, rmse_, mape_))
